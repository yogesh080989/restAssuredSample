Follow these steps strictly:

1. Understand the microservice

Extract:

Main responsibilities

All REST endpoints (HTTP method + path)

All external dependencies (DB, message queues, services, caches, third-party APIs)

Internal layers (Controllers, Services, Repositories, Adapters, Jobs)

Configuration that indicates integration points

2. Identify components

Group them into meaningful architectural components:

ApiController / Controller components (all inbound APIs)

Service components (business logic)

Repository components (data access)

ClientAdapter / Gateway components (HTTP clients to external services)

EventProducer / EventConsumer components (Kafka, RabbitMQ)

Scheduler components (cron jobs)

Any utility or workflow/orchestration components

Each component must include:

1-line responsibility

Key interfaces (endpoints or APIs used)

Technology (Spring Boot, Node.js, .NET, etc.)

3. Relationships

For every component:

Show “calls”, “reads/writes”, “publishes”, or “subscribes-to”

Represent external systems explicitly

Use proper C4 direction arrows (from caller → callee)

4. Output Structurizr DSL

Generate Structurizr DSL containing:

Workspace setup

Model

Container for the API application

Components inside that container

External systems

Relationships

Views: System Context, Container, Component

Styles (Controller, Service, Repository, ExternalSystem, Database, Queue)

Keep code clean and organized.

5. Output format

Return only the Structurizr DSL and no additional commentary unless clarification is required.

Use autolayout lr.
Use tags: Controller, Service, Repository, Gateway, Scheduler, Database, Queue, ExternalSystem.
Group endpoints into controllers logically.
If OpenAPI contains 20+ endpoints, summarize by grouping (Orders, Payments, Users, etc).

You are an expert in C4 modeling and Structurizr.  
Target: perform component discovery for a **Java Spring Boot** API microservice and output **only** a Structurizr DSL workspace (no extra commentary).

INPUT AVAILABLE: (choose all that apply) OpenAPI/Swagger JSON or YAML, Spring Boot source files (controllers, services, repositories), `application.yml` / `application.properties`, Dockerfile / Helm chart, logs/traces snippet, and any notes. Use whichever inputs are provided.

TASK — do the following steps:

1. Parse Spring Boot artifacts:
   - From source: identify classes annotated with @RestController, @Controller, @RequestMapping, @GetMapping, @PostMapping, etc. Extract method-level HTTP methods and paths.
   - Identify @Service, @Component, @Repository, @Configuration, @Bean, @ControllerAdvice, @Controller, @FeignClient, @KafkaListener, @Scheduled classes.
   - From application.yml/properties: extract datasource URLs, Redis/Cache, kafka/rabbit config, external service URLs, active profiles, feature flags, and actuator endpoints.
   - From OpenAPI/Swagger: extract endpoints, request/response models, security schemes.
   - From Docker/Helm: extract image, ports, env vars, readiness/liveness probes.

2. Create a single Structurizr workspace containing:
   - A softwareSystem representing the overall system.
   - A container named for the Spring Boot app (e.g., "Order API (Spring Boot)") with runtime technology noted ("Spring Boot 3.x, Java 17", or as found).
   - Components inside that container derived from code:
     * Controller components (group controllers by package or feature) — include sample endpoints.
     * Service components (business logic).
     * Repository components (data access / JPA repositories).
     * Client/Gateway components for outbound HTTP, Feign, RestTemplate, WebClient.
     * EventProducer/EventConsumer components for Kafka/Rabbit.
     * Scheduler components for @Scheduled jobs.
     * Configuration/Health/Metrics component (actuator).
     * Any adapters, mappers, or integration components you find.
   - External systems (databases, caches, message brokers, 3rd-party APIs) with concrete connection URIs or placeholders extracted from config.
   - Relationships with direction and annotations (e.g., "POST /orders → OrderService", "writes to orders table", "publishes order.created to Kafka topic order.events").

3. For each component include:
   - 1-line responsibility.
   - Example APIs or method signatures (controller method -> HTTP method + path).
   - Key technology (Spring MVC, Spring Data JPA, Spring Security, Spring Cloud OpenFeign, Spring Kafka, Reactor, etc.)
   - Deployment unit (jar/container/pod) and statefulness (stateless/stateful).

4. Views:
   - Provide System Context, Container, and Component views for the service.
   - Use autolayout lr.
   - Include styles and tags: Controller, Service, Repository, Gateway, Scheduler, Database, Queue, ExternalSystem.

5. Output rules:
   - Output **only** valid Structurizr DSL (no extra text).
   - Keep identifiers readable (snake_case or CamelCase).
   - If input has > 20 endpoints, group controllers by feature (e.g., OrdersController, PaymentsController) and summarize endpoints per controller (show 3 representative endpoints and "…").
   - If OpenAPI is present, prefer exact endpoints from it. Otherwise infer from @RequestMapping annotations.
   - Include component descriptions and links to source files (file path or class name) in the DSL `description` fields when available.

6. Edge cases:
   - If you detect circuit breakers (Resilience4j / Hystrix) mark them in component description.
   - If reactive stack detected (WebFlux, Reactor) indicate runtime as "Reactive".
   - If security is present (Spring Security, OAuth2, JWT) annotate which endpoints are public vs internal and list auth method.

7. Example minimal output structure required (but adapt to actual discovery):
   - workspace { model { ... } views { systemContext ... container ... component containerName ... } styles { ... } }

Produce the full Structurizr DSL now.
