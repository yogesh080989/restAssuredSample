You are an expert Java developer and a Structurizr/C4 modeling specialist.
Goal: produce Java code (and supporting files) that will generate Structurizr models for a Spring Boot microservice at build/runtime and export the model as Structurizr DSL and JSON. The code must be idiomatic, testable, and suitable for inclusion in a typical Java Spring Boot repo.

INPUT / CONTEXT

Repo conventions: Java + Spring Boot, Maven/Gradle.

Example reference test file (style & package layout) available at: /mnt/data/SpringPetClinicTests.java — use it as an example for test and package conventions.

Prefer Spring Boot 2.x/3.x patterns, JUnit 5, AssertJ for assertions.

Use the Structurizr Core Java library (e.g., com.structurizr:structurizr-core).

The microservice exposes REST controllers, services, repositories, and may use Kafka, Feign, and Spring Data.

TASKS — produce the following outputs (return only the files and code; no extra commentary):

A Java component com.yourorg.architecture.StructurizrModelGenerator

A Spring @Component or utility class that:

Scans the application code (or accepts explicit inputs) to build a Workspace and Model.

Creates: SoftwareSystem, Container for the Spring Boot app, and Component elements derived from inputs (Controllers, Services, Repositories, Clients, Schedulers).

Adds relationships:

user → controller endpoints (include example endpoints)

controller → service → repository

service → external system (DB, Kafka, 3rd-party APIs)

Adds tags and sensible styles (Controller, Service, Repository, Database, Queue, ExternalSystem).

Populates description with one-line responsibilities and properties where useful (e.g., healthEndpoint, owner).

Supports both manual discovery mode (the developer passes component definitions) and auto-discovery mode (scans @RestController, @Service, @Repository, @FeignClient, @KafkaListener, @Scheduled annotations using reflection or Spring ApplicationContext).

Exposes methods:

Workspace generateWorkspace() — builds and returns the Workspace object.

void writeDsl(Path outputPath) — writes Structurizr DSL to file.

void writeJson(Path outputPath) — writes JSON export of the workspace.

void publishToStructurizr(String apiKey, String apiSecret, long workspaceId) — optional, but include [DEMO STUB] code commented out for real Structurizr service calls (do not include credentials).

Use good logging and clear exceptions.

A Spring Boot auto-configuration or starter bean that can run generation:

@ConditionalOnProperty(name="structurizr.generate", havingValue="true") to optionally run during CI or mvn -Dstructurizr.generate=true test runs.

When enabled, generate /target/structurizr/workspace.dsl and /target/structurizr/workspace.json.

Unit tests (JUnit 5) matching your repo style (use /mnt/data/SpringPetClinicTests.java as a style reference):

StructurizrModelGeneratorTest — verifies that generateWorkspace() creates:

one container for the app

at least one Controller, Service, Repository components (even if synthetic)

relationships (controller -> service -> repository)

writes DSL and JSON files to a temp directory

Use AssertJ to check model content (names, tags, relationships).

Example usage snippet (e.g., in ApplicationRunner or a CLI main) showing how to call generator manually.

Maven/Gradle snippet showing dependencies to add:

structurizr-core

junit-jupiter

assertj-core

(optional) structurizr-client if publishing is desired

A README snippet (short, 6–8 lines) describing:

how to enable generation (structurizr.generate=true)

output locations

how to include it in CI to fail build if model generation fails

IMPLEMENTATION DETAILS / CONSTRAINTS

Keep code type-safe and well-structured; follow typical package naming (e.g., com.yourorg.architecture).

For auto-discovery, use Spring ApplicationContext.getBeansWithAnnotation(...) or classpath scanning; keep reflection minimal and safe.

Do not require network access to run generation (publishing to Structurizr is optional and must be a no-op unless credentials provided).

Exporters should use StructurizrDslWriter and WorkspaceUtils (or similar) from the Structurizr Core library for DSL/JSON output.

Include clear JavaDoc on public methods.

For security: never hardcode API keys; show commented example for how to pass them through environment vars or CI secrets.

Make tests fast (no containers).

OUTPUT FORMAT

Return Java source files (full content), test files, and the short README snippet and dependency block. Use consistent package names across files.

Ensure tests compile against the code you generated.

EXAMPLES / SAMPLES

Provide a minimal example of generated DSL (3–6 lines) at the end of the generated writeDsl result to act as a smoke-check in tests.

Edge cases

If the application is reactive (WebFlux), add a component description mentioning "Reactive".

If @FeignClient is present, create Gateway components in the model.

If Kafka listeners found, create Queue components and Producer/Consumer relationships.

Finish:
Produce the code and files now.

PROMPT END
